/*
tcltotux - a utility to convert Tux Racer Course files to Extreme Tux Racer Files.
Copyright (C) 2021  fisik_yum

This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License
as published by the Free Software Foundation; either version 2
of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.*/

package main

import (
	"bufio"
	"fmt"
	"log"
	"os"
	"strings"
)

func main() {

	keys := []string{ //declare keys for parser to recognize.
		"tux_course_author",
		"tux_course_dim",
		"tux_start_pt",
		"tux_angle",
		"tux_elev_scale"}

	file, err := os.Open("course.tcl")
	check(err)
	defer file.Close()
	fmt.Println("Successfully Opened File!")
	s := bufio.NewScanner(file)

	final := dat{}

	fmt.Println("Starting Parser")
	for s.Scan() {
		buff := strings.Split(s.Text(), " ")
		if stringInArray(buff[0], keys) {

			switch token := buff[0]; token { //switch statements make life easier

			case "tux_course_author":
				buff2 := strings.Join(buff[1:], " ")
				final.author = buff2[1 : len(buff2)-1]

			case "tux_course_dim": //dimensions
				if len(buff) < 4 { //sometime only two parameters are included
					final.width = buff[1]
					final.length = buff[2]
					final.play_width = buff[1]
					final.play_length = buff[2]
				} else { //when all four parameters are present
					final.width = buff[1]
					final.length = buff[2]
					final.play_width = buff[3]
					final.play_length = buff[4]
				}

			case "tux_start_pt": //start point will have two usable values
				final.startx = buff[1]
				final.starty = buff[2]

			case "tux_angle": //angle
				final.angle = buff[1]

			case "tux_elev_scale": //elevation height scaling
				final.scale = buff[1]

			}
		}
	}
	fmt.Println("Collecting and Formatting data")
	fmt.Println(format(final))

}

func stringInArray(a string, list []string) bool {
	for _, b := range list {
		if b == a {
			return true
		}
	}
	return false
}

type dat struct {
	author      string
	width       string
	length      string
	play_width  string
	play_length string
	startx      string
	starty      string
	angle       string
	scale       string
}

func format(d dat) string {

	//this is really long, but I'm also really lazy!
	s := fmt.Sprintf("*[width] %s [length] %s [play_width] %s [play_length] %s \n[startx]%s[starty]%s[angle]%s[scale]%s\n[theme]calm\n[env] tuxracer\n\n[author] %s\n*[desc] Generated by tcltotux", d.width, d.length, d.play_width, d.play_length, d.startx, d.starty, d.angle, d.scale, d.author)

	f, err := os.Create("course.dim")
	check(err)
	defer f.Close()
	fmt.Fprintln(f, s)

	fi, err := f.Stat()
	check(err)

	return fmt.Sprintf("Succesfully wrote file %d bytes long.", fi.Size())
}

func check(err error) {
	if err != nil {
		log.Fatal(err)
	}
}
